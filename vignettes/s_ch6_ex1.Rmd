---
title: "Chapter 6 - Example 1"
author: "Eduard"
date: "24 September 2016"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Розділ 6 - Приклад 1

**Завантаження необхідних бібліотек із функціями**
```{r message=FALSE, warning=FALSE}
library(dplyr)        # Необхідно для маніпуляції даними
library(Benchmarking) # Необхідно для аналізу ефективності
```

**Ініціалізація даних**

Спершу. ми генеруємо данні у вигляді дата фрейму (data frame)
```{r}
data <- data.frame(firms = c(LETTERS[1:7]),
                   Q = c(1, 1, 2, 3, 2, 1, 2),
                   X1 = c(2, 3, 2, 6, 6, 8, 10),
                   X2 = c(5, 2, 4, 6, 2, 2, 2),
                   stringsAsFactors = FALSE)
data$X1_per_Y <- data$X1 / data$Q     # Розрахунок нового стовпчику у даних
data$X2_per_Y <- data$X2 / data$Q     # Розрахунок нового стовпчику у даних
```

Перегляд даних
```{r}
data
```

**Оцінка технічної ефективності на основі згенерованих даних**

Оцінку технічної ефективності фірм ми проводимо за допомогою функції `dea()`(), яка міститься у пакеті `Benchmarking`. Для того, щоб функція працювала, нам необхідно подати коректні вхідні параметри у правильному вигляді.

*  Вхідні дані `data` задаються як параметри `Y` та `X`. Їх необхідно подати у вигляді матриці, тому, ми їх перетворюємо із дата фрейму у матрицю.
*  За допомогою параметру `RTS` ми визначаєм яке саме припущення ми робимо про вплив ефекту масштабу на ефективність досліджуваних фірм. Значення цього параметру "crs" означає, що ми робимо припущення про сталий ефект масштабу.
*  За допомогою параметру `ORIENTATION` визначає тип ефективності, яку ми шукаємо. Значення цього параметру "in" означає, що ми шукаємо вхід-орієнтовану ефективність.
*  Параметр `SLACK` визначає чи необхідно у результатах виконання функції розраховувати слак. Значення параметру TRUE означає, що значення слаків будуть розраховані у результатах функції.

```{r}
eff <-
  dea(
    Y = as.matrix(data[, c("Q")]),
    X = as.matrix(data[, c("X1", "X2")]),
    RTS = "crs",
    ORIENTATION = "in", 
    SLACK = TRUE
  )
```

За результатами використання функції `dea()`, ми створили об'єкт `eff`, який містить усі результуючі атрибути функції. Для того, щоб побачити, якими є ці атрибути, ми використаємо функцію `str()`. Вона показую усе із чого складається об'єкт `eff`.

```{r}
str(eff)
```

Із наведеного, нас цікавлять атрибути `eff`, `lambda` та `sx`.  

*  `eff` - це значення ефективності фірм наведені у тому порядку, в якому фірми знаходилися у вхідних даних.
*  `lambda` - це скалярні величини у вигляді дата фрейму. 
*  `sx` - це значення слаків для кожного підприємства та кожного входу у вигляді дата фрейму. 

Для того, щоб подивитися значення кожного із окремих атрибутів, ми використаємо наступні команди
```{r}
eff$eff
eff$lambda
eff$sx
```

Побудуємо результуючу таблицю ефективності, лямбд та слаків.
```{r}
eff_summary <- 
  bind_cols(data,
            data.frame(eff = eff$eff),
            data.frame(eff$lambda),
            data.frame(eff$sx))

```

Виберемо виключно ті стовпчики таблиці, які нас цікавлять.
```{r}
eff_summary <- eff_summary[, c("firms", "eff", 
                               "L1", "L2", "L3", 
                               "L4", "L5", "L6", 
                               "L7", "sx1", "sx2")]
```

**Виведення результату**
```{r}
eff_summary
```
